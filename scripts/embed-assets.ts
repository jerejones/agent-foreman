#!/usr/bin/env bun
/**
 * Asset embedding script for binary builds
 *
 * This script reads gitignore templates, plugins, and version info
 * and generates a TypeScript file with embedded assets for standalone builds.
 *
 * Usage: bun scripts/embed-assets.ts
 *        npx tsx scripts/embed-assets.ts
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..");

interface EmbeddedAsset {
  name: string;
  path: string;
  content: string;
  size: number;
}

interface EmbeddedManifest {
  version: string;
  generatedAt: string;
  gitignoreTemplates: EmbeddedAsset[];
  ruleTemplates: EmbeddedAsset[];
  plugins: EmbeddedAsset[];
}

/**
 * Read all gitignore templates
 */
function readGitignoreTemplates(): EmbeddedAsset[] {
  const templatesDir = path.join(ROOT_DIR, "src/gitignore/templates");
  const assets: EmbeddedAsset[] = [];

  if (!fs.existsSync(templatesDir)) {
    console.warn("âš  Gitignore templates directory not found:", templatesDir);
    return assets;
  }

  const files = fs.readdirSync(templatesDir).filter((f) => f.endsWith(".gitignore"));

  for (const file of files) {
    const filePath = path.join(templatesDir, file);
    const content = fs.readFileSync(filePath, "utf-8");
    const name = file.replace(".gitignore", "");

    assets.push({
      name,
      path: `gitignore/templates/${file}`,
      content,
      size: content.length,
    });
  }

  return assets;
}

/**
 * Read all rule templates
 */
function readRuleTemplates(): EmbeddedAsset[] {
  const templatesDir = path.join(ROOT_DIR, "src/rules/templates");
  const assets: EmbeddedAsset[] = [];

  if (!fs.existsSync(templatesDir)) {
    console.warn("âš  Rule templates directory not found:", templatesDir);
    return assets;
  }

  const files = fs.readdirSync(templatesDir).filter((f) => f.endsWith(".md"));

  for (const file of files) {
    const filePath = path.join(templatesDir, file);
    const content = fs.readFileSync(filePath, "utf-8");
    const name = file.replace(".md", "");

    assets.push({
      name,
      path: `rules/templates/${file}`,
      content,
      size: content.length,
    });
  }

  return assets;
}

/**
 * Read plugin files for embedding
 */
function readPluginFiles(): EmbeddedAsset[] {
  const pluginsDir = path.join(ROOT_DIR, "plugins");
  const assets: EmbeddedAsset[] = [];

  if (!fs.existsSync(pluginsDir)) {
    console.warn("âš  Plugins directory not found:", pluginsDir);
    return assets;
  }

  // Walk the plugins directory recursively
  function walkDir(dir: string, basePath: string = ""): void {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const relativePath = path.join(basePath, entry.name);

      if (entry.isDirectory()) {
        walkDir(fullPath, relativePath);
      } else if (entry.isFile()) {
        // Only embed text files (md, json, txt)
        const ext = path.extname(entry.name).toLowerCase();
        if ([".md", ".json", ".txt", ".yaml", ".yml"].includes(ext)) {
          const content = fs.readFileSync(fullPath, "utf-8");
          assets.push({
            name: relativePath.replace(/\\/g, "/"), // Normalize path separators
            path: `plugins/${relativePath.replace(/\\/g, "/")}`,
            content,
            size: content.length,
          });
        }
      }
    }
  }

  walkDir(pluginsDir);
  return assets;
}

/**
 * Read package version
 */
function readVersion(): string {
  const packageJsonPath = path.join(ROOT_DIR, "package.json");
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
  return packageJson.version;
}

/**
 * Generate TypeScript code for embedded assets
 */
function generateEmbeddedCode(manifest: EmbeddedManifest): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * Auto-generated embedded assets for binary builds");
  lines.push(` * Generated at: ${manifest.generatedAt}`);
  lines.push(` * Version: ${manifest.version}`);
  lines.push(" *");
  lines.push(" * DO NOT EDIT - This file is auto-generated by scripts/embed-assets.ts");
  lines.push(" */");
  lines.push("");
  lines.push("/** Embedded version from package.json */");
  lines.push(`export const EMBEDDED_VERSION = "${manifest.version}";`);
  lines.push("");
  lines.push("/** Generation timestamp */");
  lines.push(`export const EMBEDDED_GENERATED_AT = "${manifest.generatedAt}";`);
  lines.push("");

  // Generate gitignore templates map
  lines.push("/** Embedded gitignore templates */");
  lines.push("export const EMBEDDED_GITIGNORE_TEMPLATES: Record<string, string> = {");
  for (const template of manifest.gitignoreTemplates) {
    const escaped = JSON.stringify(template.content);
    lines.push(`  ${JSON.stringify(template.name)}: ${escaped},`);
  }
  lines.push("};");
  lines.push("");

  // Generate rule templates map
  lines.push("/** Embedded rule templates */");
  lines.push("export const EMBEDDED_RULES: Record<string, string> = {");
  for (const rule of manifest.ruleTemplates) {
    const escaped = JSON.stringify(rule.content);
    lines.push(`  ${JSON.stringify(rule.name)}: ${escaped},`);
  }
  lines.push("};");
  lines.push("");

  // Generate plugins map
  lines.push("/** Embedded plugin files */");
  lines.push("export const EMBEDDED_PLUGINS: Record<string, string> = {");
  for (const plugin of manifest.plugins) {
    const escaped = JSON.stringify(plugin.content);
    lines.push(`  ${JSON.stringify(plugin.name)}: ${escaped},`);
  }
  lines.push("};");
  lines.push("");

  // Helper functions
  lines.push("/**");
  lines.push(" * Get embedded gitignore template by name");
  lines.push(" */");
  lines.push("export function getEmbeddedGitignoreTemplate(name: string): string | null {");
  lines.push("  return EMBEDDED_GITIGNORE_TEMPLATES[name] ?? null;");
  lines.push("}");
  lines.push("");

  lines.push("/**");
  lines.push(" * Get embedded plugin file by path");
  lines.push(" */");
  lines.push("export function getEmbeddedPluginFile(path: string): string | null {");
  lines.push("  return EMBEDDED_PLUGINS[path] ?? null;");
  lines.push("}");
  lines.push("");

  lines.push("/**");
  lines.push(" * List all embedded gitignore template names");
  lines.push(" */");
  lines.push("export function listEmbeddedGitignoreTemplates(): string[] {");
  lines.push("  return Object.keys(EMBEDDED_GITIGNORE_TEMPLATES);");
  lines.push("}");
  lines.push("");

  lines.push("/**");
  lines.push(" * List all embedded plugin file paths");
  lines.push(" */");
  lines.push("export function listEmbeddedPluginFiles(): string[] {");
  lines.push("  return Object.keys(EMBEDDED_PLUGINS);");
  lines.push("}");
  lines.push("");

  lines.push("/**");
  lines.push(" * Get embedded rule template by name");
  lines.push(" */");
  lines.push("export function getEmbeddedRuleTemplate(name: string): string | null {");
  lines.push("  return EMBEDDED_RULES[name] ?? null;");
  lines.push("}");
  lines.push("");

  lines.push("/**");
  lines.push(" * List all embedded rule template names");
  lines.push(" */");
  lines.push("export function listEmbeddedRuleTemplates(): string[] {");
  lines.push("  return Object.keys(EMBEDDED_RULES);");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Main entry point
 */
async function main(): Promise<void> {
  console.log("ðŸ”§ Embedding assets for binary build...\n");

  // Read assets
  const version = readVersion();
  console.log(`ðŸ“¦ Version: ${version}`);

  const gitignoreTemplates = readGitignoreTemplates();
  console.log(`ðŸ“„ Gitignore templates: ${gitignoreTemplates.length}`);
  for (const t of gitignoreTemplates) {
    console.log(`   - ${t.name} (${t.size} bytes)`);
  }

  const ruleTemplates = readRuleTemplates();
  console.log(`ðŸ“‹ Rule templates: ${ruleTemplates.length}`);
  for (const r of ruleTemplates) {
    console.log(`   - ${r.name} (${r.size} bytes)`);
  }

  const plugins = readPluginFiles();
  console.log(`ðŸ”Œ Plugin files: ${plugins.length}`);

  // Create manifest
  const manifest: EmbeddedManifest = {
    version,
    generatedAt: new Date().toISOString(),
    gitignoreTemplates,
    ruleTemplates,
    plugins,
  };

  // Generate code
  const code = generateEmbeddedCode(manifest);

  // Write output
  const outputPath = path.join(ROOT_DIR, "src/embedded-assets.generated.ts");
  fs.writeFileSync(outputPath, code);
  console.log(`\nâœ… Generated: ${outputPath}`);
  console.log(`   Total size: ${code.length} bytes`);

  // Calculate total embedded content size
  const totalContentSize =
    gitignoreTemplates.reduce((sum, t) => sum + t.size, 0) +
    ruleTemplates.reduce((sum, r) => sum + r.size, 0) +
    plugins.reduce((sum, p) => sum + p.size, 0);
  console.log(`   Embedded content: ${totalContentSize} bytes`);
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
